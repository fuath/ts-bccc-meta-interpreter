[ ] fun2, fun3
[ ] monadicity of ccc's
[ ] distributive laws applied to monadic combinators such as parallel/concurrent
[ ] fixpoint operator
[ ] get_a, set_a can be formulated more categorically

[ ] Test
  [ ] IMP basic (non-coroutine) semantics
    [x] Boolean algebra
    [ ] Natural numbers
    [ ] Relative numbers
    [ ] Strings
    [ ] Arrays
    [ ] Tuples
    [ ] Statements
      [ ] Stmt should just become an Expr<Unit>
      [ ] Delete semicolon from Stmt
      [x] Variables and assignment
        [ ] set_v should become set_const
        [ ] set_v should accept an Expr<Val> as argument
      [x] Semicolon
      [x] while
        [ ] with fixpoint
      [x] if
      [x] <Debugger> statement
      [ ] Printing (stored in state *and* shown to screen)
    [ ] Functions
      [x] Definition (as lambda's)
      [x] Invocation
      [x] Returning
      [x] arguments must be bound in-order, not by-name
      [ ] def stores lambda in definitions, not globals
    [ ] errors
      [ ] wherever type assertion fails, instead of done
      [ ] check that the number of arguments passed to a lambda is correct
    [ ] data-oriented memory: ints, floats, strings, ..., each an array for faster lookup
    [ ] Classes
      [x] definition
      [x] constructor
      [x] heap storage
      [x] method call: this_addr->this->C_name->heap->C_def[M_name]
      [x] field get
      [x] field set
      [ ] properties (as methods)
        [ ] get
        [ ] set
      [ ] inheritance
    [ ] Multiple files and separate repo for language
    [ ] Garbage collection (and `heap_alloc` fills in the gaps)
  [ ] IMP with interruptible semantics
    [ ] whole semantics must be fully categorical
  [ ] IMP Parser to State
  [ ] IMP Parser to Coroutine
  [ ] IMP-REC Parser to Coroutine
  [ ] IMP-REC_LAMBDA Parser to Coroutine
  [ ] IMP-Typed Parser to Coroutine * CoRoutine
  [ ] memory cells (with getter/setter?)

[ ] closure of s in Option::merge is ugly and should disappear (usual trick of closure as extra dependency ignored by one of the branches)
[ ] inference is sluggish in VSCode
  [ ] split into precompiled JS libraries with .d.ts files
[ ] less interesting distributive laws
  [ ] a^1 = a (apply, curry)
  [ ] a*1 = 1*a = a (fst/snd,left-/right-map x ())
  [ ] a+0 = 0+a = a (inl/inr,left-/right-map x absurd)
  [ ] a*a = a^2 (apply to inl/inr, curry)
[ ] Memory values as sums (of basic types)
[ ] Memory operations as actual sums
[ ] Test distributivity of CCC's
