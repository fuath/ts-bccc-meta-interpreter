[ ] IMP TYPE CHECKER
  [ ] Split into multiple files
  [x] Expressions
    [x] variable lookup and assignment
    [x] int operators
      [x] +
      [x] -
      [x] /
      [x] *
      [x] %
      [x] - (unary)
    [x] float operators
      [x] +
      [x] -
      [x] /
      [x] *
      [x] - (unary)
    [x] bool operators
      [x] and
      [x] or
      [x] not
    [x] string operators
      [x] +
      [x] length
    [x] array operators
      [x] length
      [x] get
      [x] set
  [x] Statements
    [x] If
    [x] while
    [x] ;
  [ ] Functions
    [ ] Lambda's
    [ ] Function Definition
    [ ] Function invocation
  [ ] Classes
    [ ] Definition
    [ ] Inheritance
      [ ] Covariance/contravariance in all relevant expressions
    [ ] References
    [ ] Constructor
    [ ] Field lookups
    [ ] Method calling
    [ ] Generics
[ ] IMP PARSER
  [ ] distributive laws applied to monadic combinators such as parallel/concurrent
  [ ] Python
  [ ] C#

[ ] Required for basic quality but not basic functionality
  [ ] localized errors everywhere (curried parameter, used for runtime/compiler errors!)

[ ] Advanced
  [ ] closures (closure is extra scope passed to lambda upon call, and stored with lambda in state; it goes in the state *before* the parameters)

[ ] Performance optimisations
  [ ] Use mutable state, then clone it to the immutable memory upon `dbg`
  [ ] Data-oriented memory: ints, floats, strings, ..., each an array for faster lookup
  [ ] Invoke statically typed semantics
[ ] Cleanup/whishlist
  [ ] `while` with fixpoint
  [ ] `resolve_method` with fixpoint
  [ ] Whole semantics must be fully categorical: no apply, almost everything becomes Fun<a,b>
  [ ] Garbage collection (and `heap_alloc` fills in the gaps)
  [ ] Memory values as sums (of basic types)
